{"title":"Iterationen und Funktionen","markdown":{"headingText":"Iterationen und Funktionen","containsRefs":false,"markdown":"\n\nWir haben im [vorherigen Kapitel](../chapter_03/Intro_Python.ipynb) festgestellt, dass der von uns teilweise verbesserte Code immer noch sehr repetitiv ist. Dafür gab es zwei Gründe\n\n1. Der Code ist repetitiv, d.h. Wiederholungen von sehr ähnlichen Dingen\n\n2. Der Code ist unflexibel, d.h. bei kleinen Veränderungen der Fragestellung bereits unbrauchbar\n\nWir werden in diesem Kapitel zwei wichtige Coding-Konstrukte vorstellen, die uns helfen, den Code weiter zu verbessern und die angesprochenen Probleme des bisherigen Codes zu verbessern. \n\nWir beginnen mit dem Konstrukt der `Funktionen`, bevor wir uns dem Konstrukt der `Iterationen` widmen.\n\n\n## Funktionen (build-in)\n\nWir können Funktionen einsetzen, um Teile des Codes wiederverwendbar zu machen bzw. um bereits geschriebenen Code von anderen wiederzuverwenden. Das Konstrukt ist sehr mächtig und wir werden sowohl bereits implementierte Funktionen nutzen, als auch eigene Funktionen schreiben lernen. \n\nLassen Sie uns wieder eine Analogie aus Excel nutzen. Stellen Sie sich vor, wir haben eine Spalte mit vielen Werten und wir wollen wissen, um wieviele Werte es sich handelt, d.h. wir wollen die `Anzahl` an Werten bestimmen. Wir könnten diese Information z.B. benötigen, um einen Durchschnitt zu berechnen. \n\n![Zahlen](../assets/RndNumbers.png)\n\nNatürlich könnten wir die Anzahl an Werten selber und manuell zählen (es sind 10 Werte). Diese Lösung ist aber wenig sinnvoll, da wir so einen manuellen Schritt in unser \"Programm\" einbauen. Besser wäre es, wenn wir die Anzahl an Werten automatisiert bestimmen. Wir könnten uns über diese eigentlich triviale Aufgabe nun Gedanken machen. Jedoch müssen wir dies nicht, da es für diese spezielle Frage bereits eine Lösung in Excel gibt. Wir können die Funktion `Anzahl()` nutzen, die Excel bzw. Microsoft bereits für den Anwender zur Verfügung gestellt hat. Die Funktion berechnet, wie viele Zellen in einem Bereich Zahlen enthalten. \n\n![Werte2](../assets/RndNumbers_Solution.png)\n\n\nEin Großteil der Funktionalität von Excel geht auf die breite Palette an bereits verfügbaren Funktionen zurück. \n\nSchauen wir uns nun das Äquivalent in Python an. Wir können die Anzahl an Elementen in z.B. einer Liste über die Funktion `len` ermitteln. \n\n**Beispiel**\n\nZum Aufrufen einer Funktion benötigen wir in Python \n\n- den Namen der Funktion\n- die benötigten Parameter für die Funktion\n\nDer Name der Funktion lautet `len`. Die Funktion wird dann aber erst ausgeführt (bzw. aufgerufen), in dem der Funktion die benötigten Parameter übergeben werden. Bei der Funktion `len` ist dies z.B. eine Liste, deren Anzahl an Elementen bestimmt werden soll. \n\nWenn wir eine bestehende Funktion nutzen wollen, schreiben wir also immer:\n\n```\n<funktionsname>(<parameter>, ...)\n```\n\nDie \"`...`\" stehen hier für weitere Parameter, die ggf. für eine Funktion benötigt werden. Das Vorgehen ist also prinzipiell sehr ähnlich zum Vorgehen bei Excel. \n\n```{admonition} Hilfe zu Funktionen\n:class: tip, dropdown\nWir können zu nahezu allen Funktionen Hilfe nachschlagen. \n\nDies machen wir entweder, in dem wir ein \"`?`\" hinter die Funktion schreiben. Wenn Sie z.B. wissen wollen, was die Funktion `len` tut, dann schreiben Sie in eine Code-Zelle `len?` und Ihnen werden Erläuterungen dazu angezeigt.\n\nIn einem Jupyter Notebook können Sie alternativ auch den Funktionsnamen + \"`()`\" und dann einmal `shift` + `tab` drücken. \n\nDarüber hinaus können Sie sich noch die Dokumentation von Funktionen anschauen, die Sie meist online finden werden. \n```\n\nIn Python gibt es viele Funktionen, die wir nutzen können, um uns eigenen Programmieraufwand zu sparen. Die vollständige Liste aller sog. build-in Funktionen kann [hier](https://www.w3schools.com/python/python_ref_functions.asp) nachgeschlagen werden. Hierbei handelt es sich jedoch nur um Funktionen, die bereits in Python enthalten sind. Darüber hinaus können wir andere Bibliotheken installieren, um das Spektrum signifikant zu erweitern; dies werden wir in den nächsten Kapiteln auch tun.   \n\n(kapitel:iterationen)=\n## Iterationen\n\nDas Wiederholen von identischen oder sehr ähnlichen Code-Ausschnitten ist aufwändig und fehleranfällig und sollte deshalb nicht vom Menschen, sondern vom Computer übernommen werden. \n\nAuch an dieser Stelle wollen wir uns wieder einer Analogie aus Excel bedienen. Die Stärke von Excel ist unter anderem dadurch begründet, dass wir Operationen vielfach durchführen können, ohne diese mehrfach sexplizit formuliert zu haben. Wir können stattdessen einmal formulierte Operationen \"nach unten\" oder \"zur Seite ziehen\". Dadurch kann eine Operation automatisch für eine andere Zelle angewandt werden. \n\nHier ein Beispiel in Excel, die eine Formel für viele Zellen anwendet.\n\n![xls-for-loop](../assets/xls_for_loop.gif)\n\nDas Beispiel zeigt, dass wir dadurch viel manuellen Aufwand, aber auch viele potenzielle Fehlerquellen vermeiden. \n\nAuch viele Programmiersprachen haben deshalb Konstrukte, um diese Wiederholungen zu vermeiden. Wir werden uns nun zwei Konstrukten in Python widmen:\n\n1. For-Loops\n   \n2. List comprehensions\n\n\n### For-Loops\n\nMit einer `For-Loop` können wir (iterierbare) Datentypen durchlaufen. Schauen wir uns ein Beispiel an, um zu verdeutlichen, was damit gemeint ist. \n\n**Beispiel**\n\nDas Äquivalent in Excel würde wie folgt aussehen:\n\n![xls-for-loop2](../assets/xls_for_loop2.gif)\n\nIm obigen Python-Beispiel definieren wir eine Variabel `liste_namen`. Diese ist vom Datentyp `list`. Listen sind in Python immer iterierbar, d.h. wir können diese mittels einer `for-loop` durchlaufen. Wir tun dies in dem wir schreiben \n\n`for <name> in <liste_name>:`\n\nDies zeigt Python an, dass wir die Liste `liste_namen` durchlaufen wollen und für jedes Element - wir bezeichnen es hier als `name` - etwas tun möchten. Unter dieser Definition schreiben wir dann - eingerückt mit `4 Leerzeichen` bzw. `tab` - , was wir konkret tun möchten. In unserem Falle wollen wir nur etwas ausgeben lassen. Hierfür nutzen wir eine der build-in Funktionen (`print`). Wenn wir Zwischenergebnisse innerhalb einer `for-loop` nicht in Variabeln \"abspeichern\", sondern nur anzeigen lassen wollen, müssen wir immer die (build-in) Funktion `print` nutzen.  \n\nJede For-Schleife in Python hat also immer die folgende grundsätzliche Strukur:\n\n    >>> for <element> in <objekt>:\n            mach irgendetwas\n        \nHierbei muss `objekt` iterierbar sein. `element` können wir uns als eine Art Platzhalter für das jeweilige Element vorstellen. Wir können hier auch jeden anderen Namen wählen. Wir sollten uns jedoch angewöhnen sinnvolle und beschreibende Namen zu wählen. \n\nLassen Sie uns unser neu gewonnenes Wissen kombinieren und folgende Aufgabe in Python lösen. \n\n**Aufgabe:**  \nWir haben eine Liste mit Namen und wollen bestimmen, wieviel Buchstaben jeder Name hat. \n\n**Lösung**  \nWir können dafür die Liste der Namen durchlaufen und für jedes Element der Liste, die Länge des Namen mit der Funktion `len` bestimmen. \n\nAlternativ könnten wir die Länge der Buchstaben auch in einer neuen Liste speichern - dies ist immer dann sinnvoll, wenn wir die Zwischenergebnisse später in unserem Code noch benötigen. \n\n**Beispiel**  \nWir erstellen dafür eine leere Liste (\"`[]`\"), die wir dann mit jeder Iteration mit der Anzahl an Buchstaben befüllen. Dafür benutzen wir die \"Funktion\" `.append`, die der Datentyp `list` bereitstellt. \n\n\n\n````{admonition} enumerate\n:class: tip\nWir können mittels der (build-in) Funktion `enumerate` zusätzlich zum einzelnen Element der Liste auch die Position des Elements in der Liste ausgeben lassen. Wir generieren dadurch eine Art Zähler.\n\n```{code} Python\nzahlen = [12, 14, 230]\nfor i, zahl in enumerate(zahlen):\n    print(i, zahl)\n>>> 0 12\n>>> 1 14\n>>> 2 230\n```\n\n````\n\n### List comprehension\n\nEine Besonderheit in Python sind die sog. `list comprehensions`. Mit diesen können die Ergebnisse einer `for-loop` direkt in einer neuen Liste abgespeichert werden.[^1]\n\nWir können das obige Beispiel mit dem Konstrukt der `list comprehension` einfacher und kompakter darstellen. \n\n[^1]: Hinweis: wir können innerhalb der `list comprehension` auch noch mehr machen. Dies werden wir in den nächsten Kapiteln noch sehen. \n\n```\n>>> [mach irgendetwas for <element> in <objekt>]\n```\n\nIn Python werden - wenn möglich - typischerweise `list comprehension` bevorzugt, da dies den Code insgesamt übersichtlicher und lesbarer macht. \n\n## Nützliche Funktionen\n\nAn dieser Stelle wollen wir einige ausgewählte Funktionen vorstellen, von denen wir glauben, dass sie gerade zu Anfang besonders nützlich sind. Wir werden jeweils kurz darauf eingehen, weshalb diese nützlich sind.\n\n**`print`**\n\nDie Funktion akzeptiert eine beliebige Anzahl an Parametern und gibt diese in Form von Text aus. Die Funktion ist sehr nützlich, da wir z.B. auch Zwischenergebnisse innerhalb einer Code-Zelle anzeigen lassen können. \n\nBeispiel:\n\n**`len`**\n\nDie Funktion gibt die Länge einer Liste (und vieler anderer Datentypen) an. Wir benötigen diese Funktion sehr häufig, da wir die Information, wie viele Elemente ein Objekt hat sehr häufig benötigen. \n\nBeispiel:\n\n(beispiel:range)=\n\n**`range`**\n\nDie Funktion gibt eine Zahlensequenz zurück, die standardmäßig bei `0` beginnt, sich um jeweils `1` erhöht und bei einer angegebenen Zahl endet.\n\nNun fragen Sie sich vielleicht, weshalb Sie eine solche Funktion benötigen. Diese Frage ist natürlich abhängig vom spezifischen Kontext bzw. Problem, welches Sie programmieren. Jedoch gibt es z.B. in Excel einen Anwendungsfall, auf denen viele von Ihnen schon mal gestoßen sind: Sie wollen z.B. einen Index erstellen. In Excel wird dies z.B. oft wie dargestellt gemacht.\n\n![rangeExcel](../assets/nparange_xls.gif)\n\nIn Python können Sie dies mit der Funktion `range` erreichen. \n\nDer Startpunkt, der Zählschritt sowie der Endpunkt können dabei jedoch auch explizit vorgegeben und so geändert werden. Im unteren Beispiel startet die Zahlensequenz bei 10, erhöht sich mit jedem Schritt um 2 und endet bei 19 (d.h. der gewählte Endpunkt ist nicht mit enthalten).\n\n**`enumerate`**\n\nDie Funktion fügt einem iterierbaren Objekt einen Zähler hinzu. Wir können diese Funktion immer dann nutzen, wenn wir einer For-Loop einen Zählern hinzufügen möchten. \n\nBeispiel:\n\n**`zip`**\n\nMit der Funktion kann ich zwei (oder mehr) iterierbare Datentypen (siehe [Sektion Iterationen](kapitel:iterationen)) parallel iterieren.  Dieses Konstrukt wird häufig in List-Comprehensions bzw. For-Loops genutzt. \n\nBeispiel:\n\n## Optimierung des Beispiels\n\nWir haben nun das nötige Wissen, um unser Ausgangsbeispiel signifikant zu optimieren. Schauen wir uns dafür nochmal einen Ausschnitt unseres Codes an. \n\nWie können wir den Code nun optimieren? Schauen wir uns den Code genauer an, dann stellen wir fest, dass \n\n1. wir die Berechnung einzelnen Barwerte insgesamt 4 Mal wiederholen, d.h. wir schreiben zu jedem Zeitpunkt $\\frac{CF_t}{(1+i)^t}.\n\n2. wir summieren die berechneten Barwerte auf, in dem wir jeweils \"`+`\" schreiben. \n\nWir können den Code nun verbessern, in dem wir für die Berechnung der einzelnen Barwerte eine `for-loop` bzw. eine `list comprehension` nutzen. Dadurch vermeiden wir repetitiven Code. Die Addition der einzelnen Barwerte können wir dann über die Funktion `sum` durchführen. Dadurch machen wir unseren Code flexibler z.B. für den Fall, wenn ein Projekt weniger oder mehr Cashflows beinhaltet. \n\nHier der Code in zwei einzelnen Schritten\n\n1. Berechnung der Barwerte\n\n2. Summierung der Barwerte\n\n\n\n\nWir können sogar noch einen Schritt weitergehen und beide Berechnung zusammenführen.\n\nDie optimierte Lösung ist sehr viel kompakter und funktioniert auch für jede beliebige andere Anzahl an Cashflows, d.h. wir haben einen Lösungsansatz gefunden, der für eine beliebige Anzahl an Cash Flows und einen anzugebenden Zinssatz den Kapitalwert berechnet. \n\n## Definition von eigenen Funktionen\n\nWir haben uns bereits einige Funktionen angeschaut, die von Python bereitgestellt werden. Lassen Sie uns nun damit beschäftigen, wie wir eigene Funktionen schreiben. Bevor wir dies tun wollen wir jedoch kurz darauf eingehen, weshalb dies sinnvoll ist. Aus unserer Sicht gibt es zwei gute Gründe, weshalb wir eigene Funktionen schreiben sollten. Zum einen macht dies den Code lesbarer und zum anderen führt dies zu weniger repetitivem und damit kompakteren Code. \n\n\n[HINWEIS: WARUM REITEN WIR AUF LESBARKEIT VON CODE RUM -> unser zukunftiges Ich wird Code oft nicht mehr verstehen und kann diesen deshalb nicht anpassen]\n\n\nNehmen wir unser Beispiel der Bewertung eines Projektes. Stellen wir uns vor, dass wir nun für alle drei Szenarien den Kapitalwert ermitteln wollen.[^2]  \n\n[^2]: an dieser Stelle der Hinweis, dass sich hierfür Excel vermutlich besser eignet, wir dieses Beispiel aus didaktischen Gründen aber fortführen werden. \n\nDer Code dafür könnte wie folgt aussehen:\n\n\nWir stellen fest, dass der Code wieder sehr repetitiv ist. Wir könnten die jeweiligen Berechnungen deshalb z.B. in eine `for-loop` verlagen. Das sähe dann so aus:\n\n(code:long)=\n\nDer Code sieht schon kompakter aus. Was aber, wenn wir weitere Projekte bewerten wollen? Wir müssten diesen Code mehrmals nutzen, um die jeweiligen Projekte zu bewerten. Genau für ein solches Szenario bietet sich an, die Funktionalität des Codes in eine eigene Funktion auszulagern. Wir müssten dann immer nur die Funktion aufrufen und nicht die vielen Zeilen Code wiederholen. \n\nSchauen wir uns an, wie wir Funktionen in Python schreiben. In Python ist jede Funktion wie folgt aufgebaut:\n```\n>>> def funcname(parameter, ...):\n        mach irgendetwas\n        return ergebnis\n```\n\nJede Funktion beginnt mit dem Wort \"`def`\" und einem Namen für die Funktion. Diesen können wir frei wählen. Der Name sollte beschreiben, was die Funktion tut. Darüber hinaus geben wir an, welche Informationen bzw. welche `parameter` die Funktion benötigt. Im inneren der Funktion definieren wir dann, was die Funktion tut. Das Ergebnis der Funktion wird dann via `return` ausgegeben. \n\nSobald eine Funktion definiert ist, kann diese überall im Programm genutzt werden, indem diese über \"`()`\" aufgerufen wird. \n\nSchauen wir uns **zwei einfache Beispiele** an:\n\nEs ist sehr einfach, in Python eigene Funktionen zu definieren. Wir sollten deshalb auch - wenn es sinnvoll erscheint - davon gebrauch machen. Schauen wir uns an, wie wir die Kapitalwertberechnung in eine Funktion \"auslagern\" können. \n\nWir müssen uns Gedanken machen zu verschiedenen Dingen:\n\n1. Wie soll die Funktion heißen (Funktionsname)\n2. Welche Informationen benötigt die Funktion (Funktionsparameter)\n3. Welche Berechnungen soll die Funktion im inneren Durchführen (Funktionsinhalt)\n4. Was soll die Funktion ausgeben (Funktionsoutput)\n\nFür 1.: sollten wir einen Namen wählen, der beschreibt, was die Funktion macht. Wir wählen also z.B. `berechne_kapitalwert`. An dieser Stelle der Hinweis, dass es sehr üblich ist in englischer Sprache zu coden, d.h. für Variabeln und Funktionen englische Begriffe zu wählen. \n\nFür 2.: wir benötigen Cash Flows und Zinssatz, um die Berechnungen durchzuführen. \n\nFür 3: den Code zur Berechnung des Kapitalwertes haben wir bereits geschrieben. Dies ist auch ein sehr übliches Vorgehen. Wir schreiben Code, probieren aus etc. Sobald wir merken, dass der Code funktioniert und ausgelagert werden könnte, beginnen wir diesen in Funktionen auszulagern. \n\nFür 4: die Funktion sollten den Kapitalwert als Ergebnis ausgeben.\n\nDer Code für unsere erste eigene Funktion könnnte also z.B. so aussehen:\n\nWir können unsere Funktion nun testen, in dem wir für `cashflows` und `zins` Werte einsetzen und die Funktion aufrufen. Wir können dies auf verschiedene Weise machen. Hier ein paar Beispiele, die funktionieren.\n\n**Beispiel 1: ohne vorherige Definition der Input-Variablen**\n\n**Beispiel 2: mit vorherige Definition der Input-Variablen**\n\nWichtig: die Namen der Variablen müssen nicht mit den Parameternamen übereinstimmen\n\n**Beispiel 3: mit Nennung der Parameter**\n\nIn den vorherigen Beispielen haben wir die Parameternamen nicht genannt, sondern unsere Daten nur in korrekter Reihenfolge eingegeben: 1. cashflows, 2. zins. \n\nWir können jedoch alternativ auch die Parameternamen angeben (sog. Keyword Argument). \n\nBei diesem Vorgehen ist die Reihenfolger der Parameter dann unerheblich.\n\nSchauen wir uns nun an, was der Vorteil der Auslagerung von Code-Teilen in Funktionen konkret ist. Wir werden dazu unsere drei Szenarien (siehe [hier](code:long)) \n\nDer Code ist wesentlich kompakter, weil wir das Kernstück - die Berechnung des Kapitalwertes - ausgelagert haben in eine Funktion. Auch ist der Code viel einfacher zu lesen. Wir sehen auf den ersten Blick, dass wr für verschiedene Szenarien die Funktion `berechne_kapitalwert` aufrufen. Was diese tut ist durch den gewählten Namen der Funktion fast intuitiv klar. \n\n````{admonition} Iterieren von Dictionaries\n:class: tip, dropdown\nAlternativ könnten wir das `dictionary` mit den Cashflow-Szenarien auch direkt in der `list comprehension` ansprechen. Dies ist möglich, weil ein `dictionary` wie eine Liste auch iterierbar ist. So können wir die drei Schlüssel (`key`) via `dict.keys()` und die Werte via `dict.values()` abrufen. Ersteres würde die Schlüssel \"`base`\", \"`high`\" und \"`low`\" liefern. Letzteres die entsprechenden Cashflows zu den Szenarien, d.h. \"`[-10000, 5000, 4000, 3000]`\", \"`[-10000, 6000, 5000, 4000]`\" und \"`[-10000, 4000, 3000, 1000]`\".\n\n```{code} python\nergebnisse = [berechne_kapitalwert(cash, i ) for cash in cf_szenario.values()]\n```\n\n````\n\n## Zusammenfassung und Ausblick\n\nWir haben unser Eingangsbeispiel signifikant verbessert, in dem wir uns zwei wichtige Konstrukte der Programmierung bzw. in Python angeschaut haben. \n\n1. Funktionen: sind eine sinnvolle Möglichkeit um wiederkehrenden Code auszulagern und wiederverwendbar zu machen. Wir können sowohl bereits existierende Funktionen nutzen, die andere für uns zur Verfügung stellen, als auch eigene Funktionen definieren. \n\n2. Iterationen: wir haben das Konstrukt der `for-loops` und der `list comprehension` kennengelernt. Wir sollten dieses Konstrukt immer dann anwenden, wenn wir Code repetitiv anwenden. \n\nMit dem bisher vorgestellten Konstrukten können Sie bereits sehr mächtige Programme schreiben. Natürlich bedarf es einem gewissen Maß an Übung, um die Syntax zu lernen, aber auch um die Anwendungsfälle zu identifizieren. Gehen Sie deshalb die Übungen dieses Kapitels sorgfältig durch. \n\nIm nächsten Kapitel werden wir uns mit weiteren wichtigen Konstrukten auseinandersetzen. \n\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"Functions_Iterations_Python.html"},"language":{},"metadata":{"lang":"de","fig-responsive":true,"quarto-version":"1.2.269","theme":"cosmo","page-layout":"full"},"extensions":{"book":{"multiFile":true}}}}}