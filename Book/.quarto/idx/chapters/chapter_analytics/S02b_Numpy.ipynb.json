{"title":"Einführung in Numpy","markdown":{"headingText":"Einführung in Numpy","containsRefs":false,"markdown":"\n\nNumpy is one of the most important libraries / modules in python. It is especially useful when working with numerical arrays (which researchers usually do). \n\n**Why is `numpy` so important:** \n\n- useful when working with numerical arrays (which researchers usually do)\n- enables store and manipulate in-memory data in Python\n- very fast (roughly $~50x$ faster than python's lists (which makes a hugh difference when working with large datasets)\n\nNumpy's functionality is very broad and we will not be able to cover all of it in this course. We will, however, focus on some basic functionality that will make your life easier when working with (research) data. \n\nAlso don't forget that you can always use `np.<TAB>` to display contents of functionality.\n\n# Creating arrays\n\nCreating a scalar\n\nThis is not very useful, however. Let's create some arrays from lists (or lists of lists) and from scratch using numpy.\n\n## from lists\n\nArrays (such as vectors or matrices) can be created from Python's lists\n\nUnlike lists `np.array` must only contain one data type (such as int, float, str). So the following is possible, but it converts all three data types to string.\n\nUsing numpy one can also create multidimensional arrays. \n\n## from scratch\n\nFor larger arrays it is usually more efficient to create arrays from scratch using internal NumPy functionality. \n\n## Checking shape and size of an array\n\nUsing `.shape` returns the dimension of the array\n\nUsing the `.size` function returns the size (i.e. the number of elements)\n\n# Accessing arrays\n\nNumpy arrays can be accessed via indexing and slicing.\n\n**Note**: as with lists the first element is at index level 0!\n\n## Indexing\n\nMultidimensional arrays can be accessed using indices separated by commas\n\nValue assigment on existing numpy arrays using the above index rules is possible\n\n## Slicing\n\nNumpy arrays can be sliced meaning taking elements from index $i_{start}$ to $i_{end}$.\n\nInstead of a single index we simply pass a slice: `start:end` or `start:end:step`\n\nThe same can be done using multidimensinal arrays\n\n# Reshaping of arrays\n\nSometimes it is necessary to reshape arrays. Here are some examples\n\n# Concatenation\n\nOne can join two arrays in NumPy several ways. The three most useful functions are: `np.concatenate`, `np.vstack`, `np.hstack`\n\nOne can use `np.concatenate` to join both arrays by passing both of them in a list (or tuple).\n\nYou can also concatenate more than two arrays.\n\nWhen working with arrays of different dimensions you can use `np.vstack` and `np.hstack`\n\n# Splitting\n\nInstead of joining you may want to split arrays. The tree most useful functions are: `np.split`, `np.vsplit`, `np.hsplit`. \n\nAll functions basically do the opposite of their concatenation counterparts.\n\n# Calculating with arrays\n\nUsing NumPy for calculations has many advantages. Especially it is much faster and often more convenient than using lists and for loops. \n\nWhen using lists calculations can become quite tedious. \n\nExample: let's take a vector, add a scalar to that vector (elementwise) and then take the sum.\n\nThis is much easier and more intuitive in NumPy as we are not required to use for loops but instead apply the operation \"+ 5\" to each element of the vector automatically (note: this is done using vectorization).\n\nTurns out this approach is also much faster than using for loops (in below example iit is roughly $1000x$ times faster)\n\n## Arithmetic operators\n\nOne can use all reguar arithmetic operator.\n\n## Exponents and logarithms\n\n\n\n**Note** Recap logarithm:\n\n$$a^b = c$$\n\nwhere:\n\n$a = $ base\n\n$b = $ exponent\n\nLogarithm:\n\n$$ log_a(c) = b$$\n\n**Example**:\n\n$$2^5 = 32$$\n\n$$log_2(32) = 5$$\n\n## Arithmetics on multiple arrays\n\n## Aggregating values in an array\n\n....\n\nFor multidimensional arrays these functions can also be used and be applied to either rows or columns.\n\n### Example: calculate z-score\n\nLet's assume we have tabular data with 5 columns. Each column represents a certain feature each of which we want to normalize using a **z-score**.\n\nFor this we need:\n\n- to know the mean and the standard deviation for each column \n- to apply (column specific) mean and standard deviation to each element of a column\n\nUsing NumPy we can do this in one line of code\n\n# Comparisons\n\n## Boolean masks\n\nWhen you need to analyse an arrays with respect to some kind of criterion, masking helps. For example, you might wish to count all values greater than a certain value, or perhaps remove all outliers that are above some threshold. In NumPy, boolean masking is often the most efficient way to accomplish these types of tasks.\n\nLet's create some random data to show how boolean masking works. \n\nHere: we create an array with 10_000 elements. Each element is chosen based on a draw from a sample of number $1, 2, \\ldots, 5$ with probability $p$.\n\nLet's count the elements that are $\\geq 3$\n\nLet's determine the sum of elements that are equal to 4\n\nHow many numbers are $\\neq 4$\n\nAre there any numbers $> 5$ in the array?\n\nNote that this works also for multidimensional data. \n\nLet's reshape the data to a $2.000 \\times 5$ dimension and count number of elements equal to 2 per column\n\n## Boolean operators\n\nWe can use **boolean operators** if we have more than one condition. This is very helpfull when putting conditions on our data. Let's consider the three most useful ones:\n\n- AND `&`\n- OR `|`\n- NOT `~` (negation)\n\nLet's count the number of elements that are *above 3* `AND` *below 6*. \n\nNote: given we are looking for the number of elements that are $4$ or $5$ this should sum up roughly to $2/10$ of the data\n\nLet's find the number of elements that have the value $1$ `OR` $7$.\n\nLet's take the opposite of the above condition and count the number of elements that are `NOT` $1$ `AND` `NOT`$7$. We can do this negating the above statement using `~`\n\nLet's check if the result makes sense. Together both statements should result in the entire data.\n\n# Using structured data\n\nNote: one can use numpy to also work with structured data. Think of structured data as an excel spreadsheet with column headers. \n\nLet's read in a csv file with salaries data. The data set contains:\n\n- three columns with 100 elements each\n- columns represent work experience\n    - column 1 (0-5 years)\n    - column 2 (6-10 years)\n    - column 3 (>10 years)\n    \n> **NOTE:** we will later on use another library called `pandas` that is build on numpy and handels structured data even better\n\nWe can than access each individual column by its name\n\nLet's compare the mean salaries per experience group\n\n> **Advanced** We can make this even more flexible and write a function that takes another function as an input\n\n# Sneak Preview to `pandas`\n\nThe above can be handeled even easier by using `pandas`. Pandas is built on numpy the functionality is very similar. \n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"S02b_Numpy.html"},"language":{},"metadata":{"lang":"de","fig-responsive":true,"quarto-version":"1.2.269","theme":"cosmo","page-layout":"full"},"extensions":{"book":{"multiFile":true}}}}}