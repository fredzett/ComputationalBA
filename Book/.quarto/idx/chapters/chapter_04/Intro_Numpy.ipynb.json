{"title":"NumPy","markdown":{"headingText":"NumPy","containsRefs":false,"markdown":"\n\n[Numpy](https://numpy.org/doc/stable/user/whatisnumpy.html) ist eines der wichtigsten Module in Python und ein Grund für das rasante Wachstum der Programmiersprache. Es ermöglicht schnelle Berechnungen mit Vektoren und Matrizen in kompakter Form. Für viele von Ihnen mag sich dies zunächst eher abschreckend denn überzeugend anhören - schließlich beschäftigen wir uns nicht mit linearer Algebra. \n\nAuch wenn dies auf den ersten Blick nicht ersichtlich erscheint, so gibt es doch  wesentliche Argumente dafür `numpy` zu verstehen. \n\nZum einen gibt es tatsächlich sehr viele Anwendungsfälle in denen wir mit Vektoren und Matrizen rechnen müssen (oder wollen). Jede Tabelle mit Daten kann als Matrix angesehen werden. Wir können uns z.B. jede Spalte in Excel als Vektor vorstellen und jedes Tabellenblatt als Matrix. Für den Fall das Vektor oder Matrix mit Zahlen[^1] befüllt sind, ist `numpy` das ideale Werkzeug. \n\nZum anderen basiseren nahezu alle Module, die im Rahmen der Datenanalyse benötigt werden \"unter der Motorhaube\" auf `numpy`. D.h. auch wenn der Nutzer von Modulen dies nicht direkt sieht, so basieren die Fähigkeiten dieser anderen Module im Hintergrund auf `numpy`; inbesondere auch das von uns im Rahmen der Datenanalyse genutzte Modul `pandas`. \n\nWir werden in diesem Kapitel deshalb `numpy` vorstellen. Da die Bibliothek jedoch sehr groß und umfangreich ist, werden wir nur einige wichtige Konzepte und Funktionen kurz vorstellen. Im Laufe der Zeit und inbesondere wenn Sie beginnen eigene Probleme mit Python lösen zu wollen, wird ihre Nachfrage nach weiteren Details zu numpy steigen. Sie werden recherchieren und neue, bessere Wege finden, um Dinge zu implementieren. Wir glauben, dass dieser \"learning on the job\"-Ansatz besser geeignet ist, als ihnen abstrakt den vollem Umfang des Moduls in diesem Kapitel vorzustellen. \n\n[^1]: theoretisch können wir auch mit anderen Datentypen (z.B. `str`) arbeiten. Der Haupteinsatzzweck sind jedoch numerische Operationen. \n\n\n\n## Einführendes Beispiel\n\n\n\nLassen Sie uns mit einem anschaulichen Beispiel beginnen, um die Vorteile der Bibliothek vorzustellen. \n\nNehmen wir an, das Unternehmen Super Sales GmbH hätte folgende Transaktionsdaten zu ihren täglichen Verkäufen:\n\n![transactions1](../assets/transactions1.png)\n\n\nGegeben ist die Kunden-ID, der Preis des Produktes und die verkaufte Produktmenge. Wir möchten nun (i) den Umsatz je Kunde sowie (ii) den gesamten Tagesumsatz berechnen. In Excel ist dies sehr einfach möglich, in dem wir eine neue Spalte _Umsatz_ erstellen, in der wir die Spalte _Preis_ mit der Spalte _Menge_ multiplizieren (Umsatz je Kunde). Von dieser neuen Spalte können wir dann die Summe nehmen (Tagesumsatz). \n\nUnsere Tabelle sieht dann wie folgt aus:\n\n![transactions2](../assets/transactions2.png)\n\n````{margin} \n```{admonition} Hinweis\n:class: note\nAktuell werden wir noch keine Daten aus anderen Daten (z.B. Excel) einlesen. Damit beschäftigen wir uns in den kommenden Kapiteln. \n```\n````\n\nStellen wir uns nun vor, wir wollen dieselbe Berechnung in Python durchführen. Wir könnten diese Berechnung mit \"pure\" Python umsetzen.\n\n\n\nSchaut man sich die Umsetzung im Detail an, dann stellen wir fest, dass wir quasi diesselbe Vorgehensweise durchgeführt haben, wie in Excel. Der Unterschied ist die Umsetzung:\n\n- Excel: wir ziehen eine Formel runter (E5 zu E10)\n- Python: wir schreiben eine For-Schleife\n\nDer bis hierhin gewählte Ansatz in Python ist relativ umständlich und - obgleich dies für unsere Zwecke aktuell noch nicht so relevant ist - auch relativ ineffizient und langsam, d.h. die Berechnung dauert in Python relativ lange.[^2]\n\n[^2]: Hinweis: dies mag für uns nicht direkt ersichtlich sein, da unser Beispiel-Code - je nach Computer - nur einige Nanosekunden benötigt, um ein Ergebnis zu errechnen. Jedoch ist es so, dass `numpy` den Code oft um ein Vielfaches beschleunigt. Bei größeren Analysen kann dies dann einen Unterschied von Sekunden, Minuten oder Stunden ausmachen. \n\nGenau hier kommt ein Vorteil von **NumPy** in Spiel. \nBeispiel in Numpy:\n\nDa Numpy für den Umgang mit Vektoren und Matrizen geschrieben wurde, ist die Umsetzung oft sehr viel einfacher und deutlich schneller. Auch liest sich der Code in unserem Beispiel einfacher, da wir tatsächlich `preis` $\\times$ `menge` schreiben können und nicht den Umweg über eine For-Schleife nehmen müssen. \n\nDiese Operation ist für den Datentyp `list` nicht definiert, wie wir an der Fehlermeldung sehen können. \n\n\nIn Numpy können wir jedoch den Datentyp `array` definieren, für welchen die o.g. Operation mathematisch interpretiert wird und die einzelnen Elemente der jeweiligen Vektoren addiert werden. Ein wesentlicher Vorteil ist also, dass ich mit Numpy-Arrays - anders als z.B. mit Listen - mathematische Operationen viel besser und kompakter umsetzen kann.  \n\n## Grundlagen\n\nIm Folgenden stellen wir wesentliche Grundlagen des Moduls vor.\n\n### Importieren des Moduls\n\nWir importieren die Bibliothek typischerweise mit folgender Zeile:\n\nWie bereits im vorherigen Kapitel dargestellt, gäbe es weitere Wege die Bibliothek oder auch nur selektive Funktionen zu importieren. Mit Bezug auf `numpy` ist es jedoch anerkannter Standard, die Bibliothek zu importieren und dann die Kurzschreibweise `np` zu wählen. Es ist deshalb zu empfehlen, diese Konvention ebenfalls zu befolgen. \n\nWir können die Zeile \n\n```\nimport numpy as np\n```\n\nlesen als \"importiere das Modul numpy und bezeichne dieses im Folgenden als np\". \n\n\n\n### Arrays\n\n\n\nKern des Moduls sind die sog. `arrays`, da dieser Datentyp viel **\"__Fähigkeiten__\"** hat, die wir im Rahmen unserer Datenanalyse brauchen.\n\nWir definieren `arrays` immer mit dem Befehl\n\n```\n>>> np.array()\n```\n\nWir können damit Vektoren und Matrizen (und auch mehrdimensionale Tensoren) erzeugen. \n\nOft erzeugen alleine die Begriffe _Vektor_ und _Matrix_ Panik und suggerieren, dass wir es mit komplexen mathematischen Objekten zu tun haben. \n\nSchauen wir uns zunächst die drei geläufigsten Beispiele\n\n- Spaltenvektor\n- Zeilenvektor\n- Matrix (zweidimensional)\n\nin **Excel** an:\n\n![Vektor_Matrix_XLS](../assets/vektoren_matrix_xls.png)\n\nAbstrahieren wir von den mathematischen Begriffen, dann sehen wir, dass es sich um \"Datenstrukturen\" handelt, die wir auch in der angewandten Praxis sehr häufig benötigen. \n\nWir können diese Strukturen in **`numpy`** sehr einfach erzeugen. \n\nAllen drei Strukturen ist gemeinsam, dass diese einfache Listen (oder Listen von Listen) nehmen und in `arrays` umwandeln. Wir erkennen das daran, dass wir in `np.arrays()` z.B. `[1,2,3,4]` hineinschreiben, was eine Liste ist. Noch offensichtlicher wird dies, wenn wir uns folgenden Code anschauen: \n\n\n\n\n\n## Rechnen mit Arrays\n\nWie in unserem Eingangsbeispiel gezeigt, ist ein wesentlicher Vorteil von Numpy, dass wir mit Arrays sehr viel besser mathematische Operationen durchführen können. Schauen wir uns ein paar wesentliche Beispiele an. \n\nWir sehen, dass mathematische Operatoren, wie `+`, `-` oder auch `*`, elementweise auf die einzelnen Elemente angewandt werden. Dies funktioniert jedoch nur, wenn die Arrays die gleiche Dimension (\"Größe\") haben. \n\nFolgender Code produziert einen Fehler, da beide Arrays unterschiedliche Größen haben.\n\nDie etwas kryptische Fehlermeldung sagt, dass die Dimensionen nicht zusammen passen und die mathematische Operation deshalb nicht erlaubt ist. Wir können die Größe bzw. die Dimensionen eines Arrays einfach bestimmen, in dem wir die Methode `.shape`  nutzen.\n\nEs gibt jedoch eine Ausnahme, für die bei unterschiedlichen Dimensionen die oben aufgeführten Operationen erlaubt sind: wenn es sich nur um eine Zahl handelt.\n\nHier zwei Beispiele\n\nFür diesen Fall genierte Numpy automatisch einen identisch großen Array für die einzelne Zahl, d.h. tatsächlich wird für den o.g. Fall folgende Berechnung im Hintergrund durchgeführt (Hinweis: dies nennt sich Broadcasting):\n\nInsgesamt hat die Nutzung von Arrays einen großen Vorteil. Erinnern wir uns an unsere Berechnung des Kapitalwertes und führen die optimierte Berechnung nun mithilfe von numpy durch. \n\nZur Erinnerung unsere Berechnung in \"pure Python\":\n\nIn Numpy können wir die Berechnung ohne For-Loop berechnen. Wir müssen dafür lediglich gleichgroße Arrays für unsere benötigten Werte definieren. Für den Fall, dass es sich um nur eine Zahl handelt, können wir darauf verzichten. Wir können den Zinssatz also als einzelne Zahl definieren. \n\nWir definieren also:\n\n1. cashflow: ist vorgegeben aus den Annahmen, wir müssen nur aus der Liste einen Array erzeugen via `np.array`\n2. Zeit: der erste Cashflow wird mit 0 potenziert, der zweite mit 1, der dritte mit 2 und der vierte mit 3. Wir benötigen also einen Array `np.array([0,1,2,3,4])`\n3. Zins: dies ist eine Konstante und damit ein einzelner Wert. Hier müssen wir keine Änderung vornehmen\n\nRechnen wir den Kapitalwert für den Base-Case via Numpy aus:\n\nWir erhalten den identischen Wert, wie in unser vorherigen Version. Der Code liest sich insgesamt auch sehr viel ähnlicher als die mathematische Formel dahinter:\n\n$$\\sum_{t=0}^{T} \\frac{CF_t}{(1+i)^t}$$\n\n\n\nJedoch ist der oben abgebildete Code sehr fehleranfällig bzw. nicht sehr flexibel. Hintergrund ist, dass wir `t` quasi händisch mit dem jeweils korrekten Zeit-Index befüllt haben. Dies hat zur Konsequenz, dass wir in unseren Code manuell eingreifen müssen, sobald sich die Anzahl an Cashflows ändert. Wir können dies jedoch mit der Funktion `np.arange` (Hinweis: die NumPy-Variante der Funktion `range`, die wir im Kapitel [Funktionen](beispiel:range) kennengelernt haben) optimieren. \n\nWir nutzen hier außerdem die Funktion `sum`. Wir können auch hier noch optimieren, indem wir die Numpy-Version, `np.sum`, wählen. Der Code in Numpy würde dann insgesamt wie folgt aussehen:\n\nDas obige Beispiel zeigt, dass wir mit Hilfe von Numpy komplexe Berechnungen durchführen können, ohne auf For-Loops zurückgreifen zu müssen. Dies macht den Code nicht nur schneller, sonder oft auch sehr viel lesbarer. \n\nNatürlich können wir die oben aufgeführte Operation dann auch wieder - wie bisher empfohlen - in eine eigene Funktion \"auslagern\". \n\n## Indexieren von Arrays\n\nWir können auf einzelne (oder mehrere) Elemente von Arrays zugreifen und Arrays beliebig \"zerschneiden\". \n\nDie Syntax dafür ist wie folgt:\n\n```\n<array>[<slice>, <slice>]\n```\n\nJedem `<slice>` können Werte für `start`, `stop` und `step` angegeben werden. Standardmäßig sind diese mit dem Wert `0` belegt. \n\nDa ein Index in Python immer mit `0` beginnt, ist dies für viele zunächst verwirrend. Jedoch gewöhnt man sich recht schnell an diese Logik. \n\nHier ein paar Beispiele:\n\n### Einzelne Elemente\n\nDies ist eine Kurzschreibweise für `start=1`, `step=1` und `stop=0`.  Zu beachten ist hier, dass auf das erste Element - wie überall in Python - mit dem Index `0` zugegriffen wird. \n\nBei einer Matrix (2-D) wird mit dem ersten Index die Zeile angesprochen und mit dem zweiten Index die Spalte. Im oberen Beispiel wählen wir also die Zeile mit Index 1 (d.h. die zweite Zeile) und die Spalte mit Index 2 (d.h. die dritte Spalte). \n\n### Mehrere Elemente\n\nÜber die Veränderung der Werte für `stop` und `step` können wir auf mehrere Elemente zugreifen. \n\nHier ein paar Beispiele:\n\n## Verbinden von Arrays\n\nWir können mithilfe von zwei Funktionen Arrays zusammenfügen bzw. verbinden. Dies machen wir mit den Funktionen \n\n- `np.vstack` und\n- `np.hstack` \n\ndas \"v\" in vstack steht hier für vertical und das \"h\" dementsprechend für horizontal. \n\nHier ein paar Beispiele, wie wir Vektoren und Matrizen miteinander verknüpfen. \n\nWichtig ist, dass die zu verknüpfenden Dimensionen zueinander passen. So wird z.B. folgender Code eine Fehlermeldung auswerfen, weil wir es mit zwei Vektoren unterschiedlicher Größe zu tun haben, die auf Zeilenebene miteinander verbunden werden sollen.  \n\nEine Verbindung via np.hstack ist hingegen kein Problem, da hier Spalten \"hinzugefügt\" werden. \n\nFür Matrizen ist das Vorgehen beim Verbinden identisch. \n\n## Vergleiche und Bedingungen\n\nSchauen wir uns an, wie wir Arrays nutzen können, um häufig benötigte Transformationen von Daten zu nutzen. \n\n\nStellen wir uns vor, wir hätten einen Datensatz mit Absatzmengen in den letzten 10 Tagen.  Nun wollen wir z.B. feststellen, \n\n- Tage an denen nichts abgesetzt wurde\n- Tage an denen der Absatz über 300 lag\n- ...\n\nWir können dies mit Numpy ganz einfach über logische Bedingungen bzw. Komparatoren abbilden. D.h. wir benötigen auch keine For-Loops\n\nWenn wir wissen wollen, wieviele Tage es mit einem Absatz von \"0\" gab, können wir wie folgt vorgehen:\n\nNumpy gibt uns einen Array mit dem Datentyp `boolean` für jedes Element zurück. Wir können dieses Ergebnis auch nutzen, um Elemente in einem Array auszuwählen. \n\nBeispiel: wir wollen für die Tage mit einem Absatz von mehr als 300 die genauen Absätze erfahren\n\nWie bereits im Kapitel über [Entscheidungsstrukturen](../chapter_03/If_Statements_Python.ipynb) gelernt, können wir auch mehrere Bedingungen verknüpfen. \n\nWollen wir also z.B. die Tage herausfiltern an denen ein Absatz zwischen 20 und 300 gemacht wurde, dann können wir wie folgt vorgehen:\n\nDie Syntax ist hier jedoch etwas anders:\n\n- `or` = `|`\n- `and` = `&` \n\nAußerdem sollten die Bedingungen jeweils in geschweiften Klammern `()` abgegrenzt werden. \n\nWir können darüber hinaus auch negieren, d.h. das Gegenteil der Bedingung abfragen. Dies machen wir mit `~`. \n\nBeispiel: das Gegenteil von \"zwischen 20 und 300\" ist \"kleiner gleich 20 oder größer gleich 300\". Dies können wir entweder explizit so formulieren oder die oben formulierte Bedingung ins Gegenteil umkehren, d.h. negieren. \n\n## Wichtige Funktionen \n\nNumpy ermöglicht es in kompakter Form und sehr effizient Berechnungen durchzuführen. Dies ist insbesondere dann der Fall, wenn wir neben den vorgestellten `Arrays` auch die speziel von Numpy bereitgestellten Funktionen nutzen. Dies verhindert oft unnötige For-Loops und macht den Code isngesamt einfacher. \n\nIm Folgenden sollen einige Funktionen vorgestellt werden, die wir im Rahmen einer Datenanalyse häufig benötigen (könnten).\n\n**`np.sum`:** wir können mit dieser Funktion summieren. Ein großer Vorteil ist, dass wir damit auch Matrizen nach bestimmten Dimensionen (über Zeilen oder Spalten) summieren können. Wir geben die Dimension mit `axis` an.\n\nDie Funktion `.sum` steht dafür exemplarisch für weitere Funktionen\n- `np.count`: zählt Anzahl der Element\n- `np.mean`: berechnet arithmetisches Mittel\n- `np.median`: berechnet Median (d.h. Wert der genau in der Mitte steht, so dass 50% der Werte ober- bzw. unterhalb liegen)\n- `np.std`: berechnet Standardabweichung\n- `np.var`: berechnet Varianz\n- ...\n\n**`np.arange`:** die Funktion ist das Numpy-Äquivalent von `range` und erstellt einen Numpy-Array der bei einem Wert startet und endet und mit einem definierten Zählschritt verändert wird. \n\n**`np.linspace`:** die Funktion ist ähnlich zu np.arange - jedoch für Dezimalzahlen. Die Funktion erstellt eine Art Zahlenstrahl mit Zahlen, die im gleichen Abstand zueinander stehen. \n\nWir definieren einen Start- und einen Stopwert sowie die Anzahl an Werte (`num`), die wir haben wollen. Die Funktion gibt dann einen Array von `num` gleichmäßig verteilte Zahlen im Intervall [Startwert; Stopwert] zurück. \n\n**`np.where`:** beim Coden - und insbesondere auch in der Datenanalyse - müssen wir häufig eine \"wenn-dann\"-Logik ausführen. Wir haben diese bereits im Rahmen der `If-Statements` kennengelernt. Mit der Funktion `np.where` können wir eine solche Logik durchführen, ohne explizit `For-Loops` zu nutzen. \n\nLassen Sie uns zunächst ein kleines Beispiel in Excel vorstellen, in welchem wir eine \"wenn-dann\"-Logik in typischer Excel-Manier anwenden. Im vorliegenden Fall haben wir eine Spalte mit Werten, für welche wir auch die Summe gebildet haben. Nun wollen wir eine neue Spalte erzeugen, in der wir jedoch nur Werte > 20 übernehmen und auch von dieser neuen Spalte die Summe bilden. \n\n![npwherexls](../assets/npwhere.gif)\n\nIm obigen Beispiel wollen wir die Summe aller Werte ermitteln, die > 20 sind. In Excel machen wir das z.B. mit einer einfachen wenn-Funktion. Wir ziehen diese dann von oben nach unten, was in Python das Äquivalent einer For-Loop ist. \n\nSchauen wir uns nun an, wie wir dies in Python via Numpy und `np.where` umsetzen können. Die Funktion funktioniert dabei grundsätzlich nach folgender Logik:\n\n```\nnp.where(<Bedingung>, <werte, wenn wahr>, <werte, wenn falsch>)\n```\n\nWir können in Numpy mit unserem bisher gewonnen Wissen die oben dargestellt Exceltabelle relativ einfach nachbilden:\n\nDie Summe über die beiden Zeilen \"Werte\" und \">20\", können wir via `np.sum` und der richtigen Indexierung erreichen. \n\nWir könnten diesen auch einmal drehen, um die Darstellung vergleichbar zu Excel zu haben. Dies machen wir mit dem Zusatz `T` (steht für transponieren).\n\n**`np.repeat` und `np.tile`:** die beiden Funktionen ermöglichen es uns einen beliebigen Array zu vervielfachen und in einen neuen Array zu speichern. \n\n- np.repeat: vervielfacht jedes Element\n- np.tile: vervielfacht den Array\n\nBeispiel:\n\nZwei Anwendungsfälle, die im Rahmen der Datenanalyse häufig vorkommen sind die Erzeugung von Vektoren oder mit Matrizen, die nur mit \"0\" oder \"1\" befüllt sind. Für diese beiden Spezialfälle gibt es spezielle Funktionen: `np.ones` und `np.zeros` \n\n**`np.unique`:** Gibt die eindeutigen/einzigartigen Werte innerhalb eines Arrays bestimmen und zählen. \n\nDie Funktion gibt im obigen Beispiel an, dass der Array `zahlen` mit insgesamt 10 Elementen fünf einzigartige Elemente hat; nämlich: 1, 2, 3, 6 und 8. Oft möchten wir auch wissen, wieviel von jedem einzigartigen Element im ursprünglichen Array gefunden wurden. Dies können wir mit dem Zusatz `return_counts` herausfinden. \n\nDie Funktion gibt in diesem Falle zwei Werte zurück. Der erste Rückgabewert - welchen wir unter dem Variablennamen `einzigartig` speichern - gibt uns wie vorher die einzigartigen Werte des Arrays zurück. Der zweite Rückgabewert (`anzahl`) gibt an, wie häufig der jeweils einzigartige Wert im Array auftritt. Zum Beispiel ist die 2 insgesamt 3x zu finden, die 8 nur 1x. \n\n## Zufallszahlen\n\nIm Rahmen der Datenanalyse benötigen wir häufig zufällige Zahlen. Auch wenn dies zunächst paradox klingen mag - schließlich haben wir es doch idealerweise mit realen Datensätzen zu tun - , gibt es dafür zwei wesentliche Argumente. Wir benötigen Zufallszahlen insbesondere dann, wenn wir\n\n1. exemplarische Daten- oder Datensätze erzeugen wollen (wie wir bereits viele genutzt haben)\n\n2. Simulationen durchspielen wollen\n\nErsteres haben wir in diesem und in den vorherigen Kapiteln bereits mehrfach gemacht. Für jedes Beispiel, welches wir erstellt haben, wurden Daten benötigt. Diese haben wir (in diesem Fall der Autor...) manuell eingegeben. Es ist wesentlich einfacher diese Daten zufällig zu erzeugen; insbesondere auch für größere Datensätze. \n\nDesweiteren können wir mit Zufallszahlen sehr komplexe Probleme und Aufgaben lösen, für die wir ggf. keine mathematische Lösung kennen. Wir nennen dies dann **Simulation**, d.h. wir simulieren das Problem vielfach und schauen, was die Lösung im Mittel ergab. \n\nZufallszahlen werden in Numpy mit dem Sub-Modul `random` erzeugt[^3]. Wir rufen dieses auf, in dem wir `np.random` eingeben. Drei wichtige - und für unsere Zwecke zunächst ausreichende Funktionen - sind dann:\n\n- `.randn`: erzeugt normalverteilte Zufallszahlen\n- `.randint`: erzeugt ganzahlige Zufallszahlen in einem gewünschten Intervall\n- `.uniform`: erzeugt uniformverteilte Zufallszahl (d.h. zwischen 0 und 1)\n- `.choice`: zieht zufällig aus einer zu definierenden Liste an Zahlen\n\n[^3]: Hinweis: es gibt auch ein bereits vorinstalliertes Modul ([`random`](https://docs.python.org/3/library/random.html)) mit welchem Zufallszahlen erzeugt werden können. Darüber hinaus gibt es viele spezielle Module / Bibliotheken, die statistische Verteilungen und Zufallszahlen aus diesen Verteilungen generieren können (z.B. [`scipy`](https://scipy.org/)). \n\nIm Falle von `.choice` können die Wahrscheinlichkeiten auch explizit hinterlegt werden:\n\n## Beispiel: Simulation\n\nLassen Sie uns an dieser Stelle ein sehr bekanntes und vom Ergebnis her für viele sehr überraschendes Wahrscheinlichkeitsproblem mit den Mitteln der Simulation lösen: **das [Geburtstagsproblem](https://en.wikipedia.org/wiki/Birthday_problem)**.\n\nBeim Geburtstagsproblem geht es darum, die Wahrscheinlichkeit dafür zu bestimmen, dass aus einer Gruppe von _n_ Personen mindestens zwei am selben Tag Geburtstag haben. \n\n**Beispiel**: wie wahrscheinlich ist es, dass aus einer Gruppe aus 23 Menschen (z.B. in einer Klasse) zwei Personen am gleichen Tag Geburtstag haben. \n\nDas Problem lässt sich natürlich mit den Mitteln der Wahrscheinlichkeitsrechnung lösen. Wenn es ihnen so wie den meisten Menschen geht, dann wird ihnen die Lösung dafür jedoch nicht sofort ins Auge springen.\n\nWir werden das Problem deshalb simulieren, d.h. wir erzeugen zufällig Gruppen mit 23 Personen und zufälligen Geburtstagen und untersuchen, wie oft mindestens zwei Personen den selben Geburtstag teilen. Sie werden feststellen, dass dieses mathematisch nicht mehr triviale Problem mit den Mitteln der Simulation sehr einfach zu lösen ist. \n\nAnnahmen:\n- Frage: wie wahrscheinlich ist es, dass bei einer Gruppe von 23 Menschen mindestens zwei Personen den gleichen Geburtstag haben\n- Gruppengröße: 23\n- Tage im Jahr: 365 (d.h. wir berücksichtigen keine Schaltjahre)\n- Geburtstage sind alle gleich wahrscheinlich (d.h. ein Geburtstag am 15. März ist genauso wahrscheinlich, wie am 29. Juli)\n\nWir können das Problem nun ganz simple programmieren, in dem wir folgende drei Schritte durchlaufen\n\n1. wir erzeugen eine Gruppe und checken, ob es mindestens 2 Personen mit dem selben Geburtstag gibt\n2. wir wiederholen Schritt 1 sehr häufig (d.h. wir erzeugen z.B. 10.000x eine Gruppe mit 23 Personen)\n3. wir zählen, wie häufig bei allen Gruppen mindestens 2 Personen den selben Geburtstag hatten\n\nHinweis: der vorgestellte Code ist nicht auf Schnelligkeit optimiert, um die Lesbarkeit und das Verständnis zu erhöhen.\n\n\n**Schritt 1:**\n\nWir haben eine Gruppe mit 23 Personen generiert, die an jeweils einem von 365 Tagen Geburtstag haben können. Nun müssen wir nur noch überprüfen, ob einer der Tage mehrfach vorkommt. Wir können dies auf verschiedene Weise machen. Der einfachste Weg ist, dass wir die Anzahl an einzigartigen Geburtstagen vergleichen mit der Gruppengröße. Wenn es weniger einzigartige Geburtstage gibt, als die Gruppe groß ist, dann muss es mehrere Personen mit dem selben Geburtstag geben. \n\nWenn der oben dargestellt Code `True` zurück gibt, gibe es weniger einzigartige Geburtstage als Personen in der Gruppe. Wir haben also Personen mit dem selben Geburtstag. Bei `False` gibt es keine Übereinstimmung.\n\nWir können Schritt 1 in einer Funktion zusammenfassen: \n\n**Schritt 2**\n\nWir simulieren nun z.B. 10.000x eine Gruppe und checken, ob es eine Übereinstimmung beim Geburtstag gab. D.h. wir wenden die Funktion `check_group` 10.000x an. Da es sich um Zufallszahlen handelt, wird dort jede Gruppe zufällig bestimmt. \n\n**Schritt 3**\n\nWir zählen, wie häufig wir eine Übereinstimmung beim Geburtstag hatten und teilen diese durch die Anzahl der Simulationen. So erhalten wir die Wahrscheinlichkeit. \n\nDie Wahrseinlichkeit beträgt - gemäß unserer Simulation - ca. 51%. Wir können die Anzahl an Simulationen erhöhen, um ein genaueres Ergebnis zu erhalten. Jedoch können wir das Ergebnis bereits mit der theoretisch (bzw. mathematisch) korrekten Lösung vergleichen. Diese lautet, dass die Wahrscheinlichkeit bei einer Gruppe von 23 Personen mindestens zwei Personen mit dem selben Geburtstag zu finden bei 50.72% liegt. Die mathematische Lösung lautet für n Tage und k Personen \n\n$$V_{nr} = \\frac{n!}{n^k(n-k)!}$$\n\nIn unserem Fall sind es 365 Tage und 23 Personen, d.h.:\n\n$$V_{nr} = \\frac{365!}{365^{23}(365-23)!} = 0.507297$$\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"Intro_Numpy.html"},"language":{},"metadata":{"lang":"de","fig-responsive":true,"quarto-version":"1.2.269","theme":"cosmo","page-layout":"full"},"extensions":{"book":{"multiFile":true}}}}}